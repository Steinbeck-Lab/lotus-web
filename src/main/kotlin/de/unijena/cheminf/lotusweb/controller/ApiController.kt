package de.unijena.cheminf.lotusweb.controller

import com.mongodb.MongoCommandException
import de.unijena.cheminf.lotusweb.lotusmodel.mongocollections.LotusUniqueNaturalProduct
import de.unijena.cheminf.lotusweb.lotusmodel.mongocollections.LotusUniqueNaturalProductRepository
import de.unijena.cheminf.lotusweb.lotusmodel.mongocollections.PubFingerprintsCounts
import de.unijena.cheminf.lotusweb.lotusmodel.mongocollections.PubFingerprintsCountsRepository
import de.unijena.cheminf.lotusweb.model.AdvancedSearchModel
import de.unijena.cheminf.lotusweb.utils.AtomContainerToUniqueNaturalProductService
import net.sf.jniinchi.INCHI_OPTION
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.fingerprint.PubchemFingerprinter
import org.openscience.cdk.inchi.InChIGeneratorFactory
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.isomorphism.*
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*
import java.net.URLDecoder
import java.util.ArrayList


@RestController
@RequestMapping("/api")
class ApiController(val lotusUniqueNaturalProductRepository: LotusUniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)
    internal var pubchemFingerprinter = PubchemFingerprinter(SilentChemObjectBuilder.getInstance())

    val options = mutableListOf(INCHI_OPTION.SNon, INCHI_OPTION.ChiralFlagOFF, INCHI_OPTION.AuxNone)

    val universalIsomorphismTester = UniversalIsomorphismTester()


    @Autowired
    lateinit var atomContainerToUniqueNaturalProductService: AtomContainerToUniqueNaturalProductService

    @Autowired
    lateinit var pubFingerprintsCountsRepository: PubFingerprintsCountsRepository



    /**
     * Advanced structure handling
     */

    @RequestMapping("/search/advanced" )
    @ResponseBody
    fun advancedSearch(@RequestParam("max-hits", required = false) maxHits:String, @RequestBody advancedSearchModel: AdvancedSearchModel): Map<String, Any>{

        println("catched advanced search")
        //println(advancedSearchModel.listOfSearchItems[1])
        try {
            return this.doAdvancedSearch(maxHits.toIntOrNull(), advancedSearchModel)
        } catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to "advanced",
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }
        }

    }



    /**
     *  Exact structure handling
     */
    @RequestMapping("/search/exact-structure")
    fun structureSearchBySmiles(@RequestParam("smiles") smiles: String, @RequestParam("type") type: String, @RequestParam("intaxonomy" , required=false) intaxonomy: String?): Map<String, Any> {

        println("received exact structure search")

        val intaxonomyparam :String? = intaxonomy

        try {
            if(intaxonomyparam.isNullOrBlank()) {
                println("intaxonomy detected null")
                if (type == "smi") {
                    return this.doExactStructureSearchBySmiles(URLDecoder.decode(smiles.trim(), "UTF-8"))
                } else {
                    return this.doExactStructureSearchByInchi(URLDecoder.decode(smiles.trim(), "UTF-8"))
                }
            }else{

                println("detected taxonomy")
                if (type == "smi") {
                    return this.doExactStructureSearchBySmilesAndTaxonomy(URLDecoder.decode(smiles.trim(), "UTF-8"), intaxonomyparam)
                } else {
                    return this.doExactStructureSearchByInchiAndTaxonomy(URLDecoder.decode(smiles.trim(), "UTF-8"), intaxonomyparam)
                }

            }
        }catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to smiles,
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }
        }



    }


    /**
     *  Substructure handling
     */
    @RequestMapping("/search/substructure")
    fun substructureSearch(@RequestParam("smiles") smiles: String , @RequestParam("type") type: String , @RequestParam("max-hits") maxHits:String , @RequestParam("intaxonomy" , required=false) intaxonomy: String?): Map<String, Any> {

        println("received substrucutre structure search")

        val intaxonomyparam :String? = intaxonomy



        try {
            if(intaxonomyparam.isNullOrBlank()) {
                return this.doSubstructureSearch(URLDecoder.decode(smiles.trim(), "UTF-8"), type, maxHits.toIntOrNull())
            }else{
                return this.doSubstructureSearchInTaxa(URLDecoder.decode(smiles.trim(), "UTF-8"), type, maxHits.toIntOrNull(), intaxonomyparam)
            }
        }catch (ex: Exception ){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to smiles,
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }
        }
    }




    /**
     *  Similarity handling
     */
    @RequestMapping("/search/similarity")
    fun similaritySearch(@RequestParam("smiles") smiles: String , @RequestParam("max-hits") maxHits:String, @RequestParam("simThreshold") simThreshold:String, @RequestParam("intaxonomy" , required=false) intaxonomy: String?): Map<String, Any> {

        val intaxonomyparam :String? = intaxonomy


        var th: Int? = simThreshold.toIntOrNull()
        th = th

        try {
            if(intaxonomyparam.isNullOrBlank()) {
                return this.doSimilaritySearch(URLDecoder.decode(smiles.trim(), "UTF-8"), maxHits.toIntOrNull(), th)
            }else{
                return this.doSimilaritySearchInTaxa(URLDecoder.decode(smiles.trim(), "UTF-8"), maxHits.toIntOrNull(), th, intaxonomyparam)
            }
        }catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to smiles,
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }

        }
    }



    /**
     * Simple (navigation bar) search handling
     */
    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") queryString: String): Map<String, Any> {
        /* switch between simple and simple heuristic search
        * the latter tries to guess the input type that could become harder with more search options
        */


        var decodedString = URLDecoder.decode(queryString.trim(), "UTF-8")
        decodedString = decodedString.replace("jjj", "%")

        try {
            return this.doSimpleSearchWithHeuristic(decodedString)
            // return this.doSimpleSearch(URLDecoder.decode(queryString.trim(), "UTF-8"))
        }catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to queryString,
                            "determinedInputType" to "none",
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }
        }
    }



    /**
     * Search by mass
     */
    @RequestMapping("/search/molweight")
    fun massSearch(@RequestParam("minMass") minMass:String, @RequestParam("maxMass") maxMass:String, @RequestParam("maxHits", required=false) maxHits:String ): Map<String, Any>{
        var minM:Double? = minMass.toDoubleOrNull()
        var maxM:Double? = maxMass.toDoubleOrNull()
        var maxNP:Int? = maxHits.toIntOrNull()

        try {
            return this.doMassSearch(minM, maxM, maxNP)
        }catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }

        }

    }



/*
    /**
     *  Searches by chem class type
     */
    @RequestMapping("/search/chemclass")
    fun searchByChemicalClassification(@RequestParam("query") queryString: String) : Map<String, Any>{
        var decodedString = URLDecoder.decode(queryString.trim(), "UTF-8")

        try {
            return this.doChemclassSearch(decodedString)

        }catch (ex: Exception){

            when(ex) {
                is MongoCommandException, is OutOfMemoryError -> {
                    val other: List<LotusUniqueNaturalProduct> = emptyList()
                    return mapOf(
                            "originalQuery" to queryString,
                            "count" to 0,
                            "naturalProducts" to  other
                    )
                }
                else -> throw ex
            }
        }
    }

*/

    /**
     *  ************************************************************************************************
     *  Search functions
     */

    /*fun doChemclassSearch(query: String): Map<String, Any>{

        println("do chem class search")

        println(query)


        val results = this.lotusUniqueNaturalProductRepository.findByChemclass(query)

        println(results.size)

        println("returning")

        return mapOf(
                "originalQuery" to query,
                "count" to results.size,
                "naturalProducts" to results
        )

    }*/


    fun doMassSearch(minMass:Double?, maxMass:Double?, maxHits:Int?): Map<String, Any>{
        println("do mass search")

        var maxResults = 100

        if(maxHits != null ){
            maxResults = maxHits
        }



        if(minMass != null && maxMass != null){
            println("both min and max")
            var results = this.lotusUniqueNaturalProductRepository.minMaxMolecularWeightSearch(minMass, maxMass, maxResults)
            println(results.size)

            println("returning")

            return mapOf(
                    "count" to results.size,
                    "naturalProducts" to results
            )
        }else if(minMass != null && maxMass == null){
            println("only min")
            var results = this.lotusUniqueNaturalProductRepository.minMolecularWeightSearch(minMass, maxResults)
            println(results.size)

            println("returning")

            return mapOf(
                    "count" to results.size,
                    "naturalProducts" to results
            )
        }else if(minMass == null && maxMass != null){
            println("only max")
            var results = this.lotusUniqueNaturalProductRepository.maxMolecularWeightSearch(maxMass, maxResults)
            println(results.size)

            println("returning")

            return mapOf(
                    "count" to results.size,
                    "naturalProducts" to results
            )
        }else{
            println("0")

            println("returning nothing")

            var results = arrayListOf<LotusUniqueNaturalProduct>()

            return mapOf(
                    "count" to 0,
                    "naturalProducts" to results
            )
        }




    }




    fun doAdvancedSearch(maxHits:Int?, advancedSearchModel: AdvancedSearchModel) : Map<String, Any>{

        var maxResults = 100

        if(maxHits != null ){
            maxResults = maxHits
        }

        val results = this.lotusUniqueNaturalProductRepository.advancedSearchWithCriteria(advancedSearchModel, maxResults)

        //results.shuffle()



        return mapOf(
                "originalQuery" to "advanced",
                "count" to results.size,
                "naturalProducts" to results
        )

    }



    fun doExactStructureSearchByInchi(smiles: String): Map<String, Any> {

        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val gen = InChIGeneratorFactory.getInstance().getInChIGenerator(queryAC, options)

            var queryInchi =  gen.getInchi()


            val results = this.lotusUniqueNaturalProductRepository.findByInchiOrInchi2D(queryInchi)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }


    fun doExactStructureSearchByInchiAndTaxonomy(smiles: String, intaxonomy:String): Map<String, Any> {

        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val gen = InChIGeneratorFactory.getInstance().getInChIGenerator(queryAC, options)

            var queryInchi =  gen.getInchi()


            val results = this.lotusUniqueNaturalProductRepository.doExactStructureSearchByInchiAndTaxonomy(queryInchi, intaxonomy)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }


    fun doExactStructureSearchBySmiles(smiles: String) : Map<String, Any>{


        try {
            //val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            //val querySmiles = smilesGenerator.create(queryAC)


            val results = this.lotusUniqueNaturalProductRepository.findBySmiles2DOrSmiles(smiles)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }

    }


    fun doExactStructureSearchBySmilesAndTaxonomy(smiles: String, intaxonomy:String) : Map<String, Any>{

        println("Searching by SMILES and taxonomy")

        try {

            val results = this.lotusUniqueNaturalProductRepository.findBySmiles2DOrSmilesAndTaxonomy(smiles,  intaxonomy)

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )
        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }

    }




    fun doSimpleSearchWithHeuristic(query: String): Map<String, Any> {
        // determine type of input on very basic principles without validation



        var excludeWords = Regex("^(alpha-|beta-).*")

        println("do simple search with heuristic")


        var inchiPattern = Regex("^InChI=.*$")
        val inchikeyPattern = Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$")
        val molecularFormulaPattern = Regex("C[0-9]+?H[0-9].+")
        var smilesPattern = Regex("^([^J][A-Za-z0-9@+\\-\\[\\]\\(\\)\\\\=#\$%]+)\$")
        val lotusPattern = Regex("^LTS[0-9]+?$")

        var naturalProducts : List<LotusUniqueNaturalProduct>
        var determinedInputType : String


        try {
            this.smilesParser.parseSmiles(query)
            determinedInputType = "SMILES"
            println("detected SMILES")

        }catch (e: InvalidSmilesException){
            println(e)
            println("did not detected smiles")
            determinedInputType = "other"
        }

        if(determinedInputType=="SMILES"){

            try {
                val queryAC: IAtomContainer = this.smilesParser.parseSmiles(query)
                val querySmiles = this.smilesGenerator.create(queryAC)
                determinedInputType = "SMILES"
                println("detected SMILES")
                naturalProducts = this.lotusUniqueNaturalProductRepository.findBySmiles2DOrSmiles(querySmiles)
                if (naturalProducts.isEmpty()) {
                    println("second try SMILES")
                    naturalProducts = this.lotusUniqueNaturalProductRepository.findBySmiles2DOrSmiles(querySmiles)

                }
            }catch (e: InvalidSmilesException){
                println("not a smiles")
                if(lotusPattern.containsMatchIn(query)) {
                    naturalProducts = this.lotusUniqueNaturalProductRepository.findByLotus_id(query)
                    determinedInputType = "LOTUS ID"
                }
                else if(inchiPattern.containsMatchIn(query)){
                    naturalProducts =  this.lotusUniqueNaturalProductRepository.findByInchiOrInchi2D(query)
                    determinedInputType = "InChi"
                }
                else if(inchikeyPattern.containsMatchIn(query)){
                    naturalProducts =  this.lotusUniqueNaturalProductRepository.findByInchikeyOrInchikey2D(query)
                    determinedInputType = "InChi Key"
                }
                else if(molecularFormulaPattern.containsMatchIn(query)){
                    naturalProducts = this.lotusUniqueNaturalProductRepository.findByMolecular_formula(query)
                    determinedInputType = "molecular formula"
                }
                else {

                    //it was probably a name


                    //naturalProducts = this.uniqueNaturalProductRepository.findByName(query)

                    //if (naturalProducts == null || naturalProducts.isEmpty()) {
                    var altQuery = query
                    if(excludeWords.containsMatchIn(query)){
                        altQuery=altQuery.replace("alpha-", "")
                        altQuery=altQuery.replace("beta-", "")
                    }
                    altQuery = "\""+altQuery+"\""
                    println(altQuery)

                    naturalProducts = this.lotusUniqueNaturalProductRepository.fuzzyNameSearch(altQuery)
                    //}
                    determinedInputType = "name"
                }
            }

        }
        else if(lotusPattern.containsMatchIn(query)){
            naturalProducts =  this.lotusUniqueNaturalProductRepository.findByLotus_id(query)
            determinedInputType = "LOTUS ID"
        }
        else if(inchiPattern.containsMatchIn(query)){
            naturalProducts =  this.lotusUniqueNaturalProductRepository.findByInchiOrInchi2D(query)
            determinedInputType = "InChi"
        }
        else if(inchikeyPattern.containsMatchIn(query)){
            naturalProducts =  this.lotusUniqueNaturalProductRepository.findByInchikeyOrInchikey2D(query)
            determinedInputType = "InChi Key"
        }
        else if(molecularFormulaPattern.containsMatchIn(query)){
            naturalProducts = this.lotusUniqueNaturalProductRepository.findByMolecular_formula(query)
            determinedInputType = "molecular formula"
        }
        else{
            //try to march by name
            println("apparently a name string")

            //try {
            //    naturalProducts = this.uniqueNaturalProductRepository.findByName(query)

            //}catch (ex: Exception){

            //    when(ex) {
            //        is MongoCommandException, is OutOfMemoryError -> {
            //            val other: List<UniqueNaturalProduct> = emptyList()
            //            return mapOf(
            //                   "originalQuery" to query,
            //                   "count" to 0,
            //                   "naturalProducts" to  other
            //           )
            //       }
            //       else -> throw ex
            //   }
            //}


            //if(naturalProducts == null || naturalProducts.isEmpty()){
            var altQuery = query
            if(excludeWords.containsMatchIn(query)){
                altQuery=altQuery.replace("alpha-", "")
                altQuery=altQuery.replace("beta-", "")
            }
            altQuery = "\""+altQuery+"\""
            println(altQuery)


            naturalProducts = this.lotusUniqueNaturalProductRepository.fuzzyNameSearch(altQuery)
            //}
            determinedInputType = "name"
        }
        println(determinedInputType)
        println("returning")

        val runtime = Runtime.getRuntime()
        println("Free memory: " + runtime.freeMemory() + " bytes.")




        return mapOf(
                "originalQuery" to query,
                "determinedInputType" to determinedInputType,
                "naturalProducts" to naturalProducts
        )
    }



    fun doSubstructureSearchInTaxa(smiles: String, type: String, maxHitsSubmitted: Int?, intaxonomy: String): Map<String, Any> {
        println("Entering substructure search with taxonomy")

        println(smiles)

        var maxResults = 100

        if(maxHitsSubmitted != null ){
            maxResults = maxHitsSubmitted
        }

        val hits = mutableListOf<LotusUniqueNaturalProduct>()
        var counter: Int = 0


        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)

            //println(pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet().toByteArray())

            // run $allBitsSet in mongo


            val matchedList = this.lotusUniqueNaturalProductRepository.findAllPubchemBitsSetWithTaxonomy(queryAC, intaxonomy)


            println("found "+matchedList.size+" molecules with bits set")
            val pattern: Pattern
            // return a list of UNP:
            if(type=="default") {
                // for each UNP - convert to IAC and run the Ullmann
                pattern = Ullmann.findSubstructure(queryAC)
                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        //println(unp.coconut_id)

                        counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }else if(type=="df"){
                pattern = DfPattern.findSubstructure(queryAC)

                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)
                    if (pattern.matches(targetAC)) {
                        hits.add(unp)
                        //println(unp.coconut_id)
                        counter++
                        //if (counter==maxResults) break@loop

                    }
                }


            }else{
                //Vento-Foggia
                pattern = VentoFoggia.findSubstructure(queryAC)
                for(unp in matchedList){ //loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        println(unp.lotus_id)

                        //counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }

            println(hits.size)
            hits.sortBy { it.total_atom_number }

            //list.sortedWith(compareBy({ it.customProperty }))
            val hitsToReturn = hits.subList(0, minOf(hits.size , maxResults))

            println("ready to return results!")

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to  hitsToReturn.size,
                    "naturalProducts" to hitsToReturn
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }

    }

    fun doSubstructureSearch(smiles: String, type: String, maxHitsSubmitted: Int?): Map<String, Any> {
        println("Entering substructure search")

        println(smiles)

        var maxResults = 100

        if(maxHitsSubmitted != null ){
            maxResults = maxHitsSubmitted
        }

        val hits = mutableListOf<LotusUniqueNaturalProduct>()
        var counter: Int = 0

        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)

            //println(pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet().toByteArray())

            // run $allBitsSet in mongo
            val barray = pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet().toByteArray()
            val matchedList = this.lotusUniqueNaturalProductRepository.findAllPubchemBitsSet(barray)

            //TODO get the exact bitset also? for faster substructure search of the first element

            println("found "+matchedList.size+" molecules with bits set")
            val pattern: Pattern
            // return a list of UNP:
            if(type=="default") {
                // for each UNP - convert to IAC and run the Ullmann
                pattern = Ullmann.findSubstructure(queryAC)
                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        //println(unp.coconut_id)

                        counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }else if(type=="df"){
                pattern = DfPattern.findSubstructure(queryAC)

                for(unp in matchedList){//loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)
                    if (pattern.matches(targetAC)) {
                        hits.add(unp)
                        //println(unp.coconut_id)
                        counter++
                        //if (counter==maxResults) break@loop

                    }
                }


            }else{
                //Vento-Foggia
                pattern = VentoFoggia.findSubstructure(queryAC)
                for(unp in matchedList){ //loop@

                    var targetAC : IAtomContainer = this.atomContainerToUniqueNaturalProductService.createAtomContainer(unp)

                    val match = pattern.match(targetAC)

                    if (match.isNotEmpty()) {
                        hits.add(unp)

                        println(unp.lotus_id)

                        //counter++

                        //if (counter==maxResults) break@loop

                    }
                }

            }

            println(hits.size)
            hits.sortBy { it.total_atom_number }

            //list.sortedWith(compareBy({ it.customProperty }))
            val hitsToReturn = hits.subList(0, minOf(hits.size , maxResults))

            println("ready to return results!")

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to  hitsToReturn.size,
                    "naturalProducts" to hitsToReturn
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }


    fun doSimilaritySearchInTaxa(smiles: String, maxHitsSubmitted: Int?, th: Int?, intaxonomy: String): Map<String, Any> {



        var threshold: Double = 0.9

        if(th != null){
            threshold = th.toDouble()/100
        }

        println("entered similarity search")

        println(smiles)

        var maxResults = 100

        if(maxHitsSubmitted != null ){
            maxResults = maxHitsSubmitted
        }


        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)

            val s = pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet()
            val queryPF = ArrayList<Int>()
            var i = s.nextSetBit(0)
            while (i != -1) {
                queryPF.add(i)
                i = s.nextSetBit(i + 1)
            }
            //queryPF is an array of indexes of ON bits for the query molecule

            var qLen : Int = queryPF.size

            var qmin = (Math.ceil(qLen * threshold)).toInt()        // Minimum number of bits in results fingerprints
            var qmax = (qLen / threshold).toInt()              // Maximum number of bits in results fingerprints
            var ncommon = qLen - qmin + 1                      // Number of fingerprint bits in which at least 1 must be in common


            var allBits: MutableList<PubFingerprintsCounts> = pubFingerprintsCountsRepository.findAll()
            allBits.sortByDescending { it.count } //sorting to have the most frequent bits first

            var requestedBits = ArrayList<Int>()

            getbits@for (bit:PubFingerprintsCounts in allBits ){
                if(bit.id in queryPF){
                    requestedBits.add(bit.id)
                }
                if(requestedBits.size==ncommon)break@getbits

            }


            val matchedList = this.lotusUniqueNaturalProductRepository.similaritySearchInTaxa(requestedBits, queryPF, qmin, qmax, qLen, threshold, maxResults, intaxonomy)

            //TODO redo a tanomoto here to be sure that the match is correct
            //println(matchedList[0].tanimoto)

            //hits.sortBy { it.heavy_atom_number }
            //val hitsToReturn = matchedList.subList(0, minOf(matchedList.size , maxResults))


            return mapOf(
                    "originalQuery" to smiles,
                    "count" to matchedList.size,
                    "naturalProducts" to matchedList
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }



    }



    fun doSimilaritySearch(smiles: String, maxHitsSubmitted: Int?, th: Int?): Map<String, Any> {


        var threshold: Double = 0.9

        if(th != null){
            threshold = th.toDouble()/100
        }

        println("entered similarity search")

        println(smiles)

        var maxResults = 100

        if(maxHitsSubmitted != null ){
            maxResults = maxHitsSubmitted
        }


        try {
            val queryAC: IAtomContainer = this.smilesParser.parseSmiles(smiles)

            val s = pubchemFingerprinter.getBitFingerprint(queryAC).asBitSet()
            val queryPF = ArrayList<Int>()
            var i = s.nextSetBit(0)
            while (i != -1) {
                queryPF.add(i)
                i = s.nextSetBit(i + 1)
            }
            //queryPF is an array of indexes of ON bits for the query molecule

            var qLen : Int = queryPF.size

            var qmin = (Math.ceil(qLen * threshold)).toInt()        // Minimum number of bits in results fingerprints
            var qmax = (qLen / threshold).toInt()              // Maximum number of bits in results fingerprints
            var ncommon = qLen - qmin + 1                      // Number of fingerprint bits in which at least 1 must be in common


            var allBits: MutableList<PubFingerprintsCounts> = pubFingerprintsCountsRepository.findAll()
            allBits.sortByDescending { it.count } //sorting to have the most frequent bits first

            var requestedBits = ArrayList<Int>()

            getbits@for (bit:PubFingerprintsCounts in allBits ){
                if(bit.id in queryPF){
                    requestedBits.add(bit.id)
                }
                if(requestedBits.size==ncommon)break@getbits

            }


            val matchedList = this.lotusUniqueNaturalProductRepository.similaritySearch(requestedBits, queryPF, qmin, qmax, qLen, threshold, maxResults)

            //TODO redo a tanomoto here to be sure that the match is correct
            //println(matchedList[0].tanimoto)

            //hits.sortBy { it.heavy_atom_number }
            //val hitsToReturn = matchedList.subList(0, minOf(matchedList.size , maxResults))


            return mapOf(
                    "originalQuery" to smiles,
                    "count" to matchedList.size,
                    "naturalProducts" to matchedList
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }



    }


}